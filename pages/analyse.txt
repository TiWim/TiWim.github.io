<!DOCTYPE html>
<html>
<title>Hacking Skills</title>
<meta id='page-params'
    theme='cyborg'
    title='Hacking Skills'
    menu='Home,index.html,GDB,pages/analyse.html,Links,pages/linklist.html,Practical Installation,pages/building.html,Wheezy Upgrade,pages/upgradeWheezy.html'
    active='2'
    root='../'>
    <xmp>


# How to analyse statically a program with GDB:

## List of useful tools:

- [strace](http://linux.die.net/man/1/strace) : Traces system calls and signals
- [ltrace](http://linux.die.net/man/1/ltrace) : Intercepts and records the dynamic libraries called by the executed process
- [readelf](http://linux.die.net/man/1/readelf) : Displays information about ELF files
- [gdb](http://linux.die.net/man/1/gdb) : GNU Debugger allows you to see what is going on inside another program
- [objdump](http://linux.die.net/man/1/objdump) : Displays information from object files
- [strings](http://linux.die.net/man/1/strings) : Prints the strings of printable characters in files
- [strip](http://linux.die.net/man/1/strip) : Discards symbols from object files
- [radare2](http://radare.org/) : Multi-architecture, cross-plateform reverse engineering framework for dissasembling (PE, ELF and mach0) and debugging
- [bokken](http://www.bokken.re/) : GTK GUI implenting most of radare2 functionalities
- [python](https://www.python.org/downloads/) : Scripting and OOP made easier

## Example:

Here is the code that I will use as example for this tutorial:

```c
// Author : TiWim
// Compilation : gcc vulnerable.c -o vulnerable -m32
// For any compilation problem, try to install libc6-dev-i386 first

#include <stdio.h>
#include <string.h>

int main (int argc, char ** argv){
    char message[20];

    if (argc != 2){
        printf ("Usage: %s <message>\n", argv[0]);
        return -1;
    }

    strcpy (message, argv[1]);
    printf ("Your message: %s\n", message);
    return 0;
}
```

> [Download this script?](../scripts/vulnerable.c)

This code is vulnerable to code injection and buffer overflows.
We will first analyse it in a 32 bits architecture without ASLR.

To disable aslr, you will have to run this command as root: __echo 0 > /proc/sys/kernel/randomize_va_space__

What can we do with this code?

We can have a new command line with the rights of the program. If the program has root privileges, we will simply have a shell with root privileges.

So, let us start with this:

__gdb ./vulnerable__

```bash
(gdb) disassemble main
Dump of assembler code for function main:
   0x0804844c <+0>: push   ebp
   0x0804844d <+1>: mov    ebp,esp
   0x0804844f <+3>: and    esp,0xfffffff0
   0x08048452 <+6>: sub    esp,0x30
   0x08048455 <+9>: cmp    DWORD PTR [ebp+0x8],0x2
   0x08048459 <+13>:    je     0x8048477 <main+43>
   0x0804845b <+15>:    mov    eax,DWORD PTR [ebp+0xc]
   0x0804845e <+18>:    mov    eax,DWORD PTR [eax]
   0x08048460 <+20>:    mov    DWORD PTR [esp+0x4],eax
   0x08048464 <+24>:    mov    DWORD PTR [esp],0x8048540
   0x0804846b <+31>:    call   0x8048320 <printf@plt>
   0x08048470 <+36>:    mov    eax,0xffffffff
   0x08048475 <+41>:    jmp    0x80484a8 <main+92>
   0x08048477 <+43>:    mov    eax,DWORD PTR [ebp+0xc]
   0x0804847a <+46>:    add    eax,0x4
   0x0804847d <+49>:    mov    eax,DWORD PTR [eax]
   0x0804847f <+51>:    mov    DWORD PTR [esp+0x4],eax
   0x08048483 <+55>:    lea    eax,[esp+0x1c]
   0x08048487 <+59>:    mov    DWORD PTR [esp],eax
   0x0804848a <+62>:    call   0x8048330 <strcpy@plt>
   0x0804848f <+67>:    lea    eax,[esp+0x1c]
   0x08048493 <+71>:    mov    DWORD PTR [esp+0x4],eax
   0x08048497 <+75>:    mov    DWORD PTR [esp],0x8048555
   0x0804849e <+82>:    call   0x8048320 <printf@plt>
   0x080484a3 <+87>:    mov    eax,0x0
   0x080484a8 <+92>:    leave
   0x080484a9 <+93>:    ret
End of assembler dump.
```

We can notice a call to the vulnerable function at main+62:
0x0804848a <+62>:    call   0x8048330 <strcpy@plt>


So, with the command __disas main__ (short for disassemble main), we can see the same code as above but in assembler.

If you want to run the program:

```bash
(gdb) r
Usage: vulnerable <message>
(gdb) r AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Your message: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
```

It is annoying and not handy to inject manually each A char, we will use python instead:
```bash
(gdb) r $(python -c "print 'A' * 40")
Your message: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
```

This is unexpected on the programmers side, but we read the code and we know that if the string is more than 20 chars long, it will segfault.
If we didn't read the code because we don't have acces to it, we can still calculate the buffer's size:

```
(gdb) i r
eax            0x0  0
ecx            0xffffd558   -10920
edx            0xf7fbd360   -134491296
ebx            0xf7fbbff4   -134496268
esp            0xffffd5b0   0xffffd5b0
ebp            0x41414141   0x41414141
esi            0x0  0
edi            0x0  0
eip            0x41414141   0x41414141
eflags         0x10292  [ AF SF IF RF ]
cs             0x23 35
ss             0x2b 43
ds             0x2b 43
es             0x2b 43
fs             0x0  0
gs             0x63 99
```

Here we can see that eip is set to 41414141 and ebp too.

We will print the stack now:
```bash
(gdb) x/20x $esp-40
0xffffd588: 0xffffd660  0x41414141  0x41414141  0x41414141
0xffffd598: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd5a8: 0x41414141  0x41414141  0x41414141  0xffffd600
0xffffd5b8: 0xffffd660  0xf7fde860  0xf7ff4821  0xffffffff
0xffffd5c8: 0xf7ffcff4  0x0804826f  0x00000001  0xffffd610
```

And the stack pointer vaults 0xffffd5b0



So, here it seems that we can control simply the execution of the program because we overwrite eip which is the instruction pointer.

We can jump to an arbitrary address.













## Software analysis:

First of all:
we need to execute the command file on the programm to verify that we are legit to disassemble it.

file ./soft

Then, we can run gdb:

gdb -q ./soft

We can disassemble some part of the software with the command disassemble:

disass main



---------------


Afficher le contenu de la stack:
x/24x $esp


Afficher une adresse:
print (void*) $esp
print (void*) $esp+0x30

Afficher le contenu d'une adresse
x/x $esp+0x30

jump *adresse
jump *main+144

stepi
nexti

br *adresse
br *main+144

continue c
run r
kill ki

watch

- Objdump
dump d'un fichier binaire en assembleur

</xmp>

<script src="../strapdown.js"></script>
</html>
